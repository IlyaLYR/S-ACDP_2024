# Задача №2

**Задание:** Реализовать структуру кода, соответствующую указанному в варианте паттерну проектирования и задаче. Функциональность для объектов задачи, где это явно не указано, реализовывать не обязательно, только обозначить (например, выводом в консоль). Написать код, использующий данную структуру. Названия сущностей (интерфейсов и классов) не обязательно должны совпадать с предложенными.


**Справочные материалы:**
- https://refactoring.guru/ru/design-patterns
- https://www.geeksforgeeks.org/software-design-patterns/


**Варианты:**
1) **Абстрактная фабрика** (Abstract Fabric)
Допустим мы пишем кросс-платформенную библиотеку пользовательского интерфейса и работаем над функциональностью окон (интерфейс Window). Каждое окно может быть перерисовано (метод repaint), свернуто/развернуто (метод toggleExpand), перемещено (метод move), изменено в размере (метод resize). Необходимо реализовать классы окон для ОС Windows, Linux, MacOS, а также фабрики по их получению.

2) **Строитель (Builder)**
Компания разрабатывает веб-приложение для управления проектами. Приложение должно поддерживать различные типы проектов, таких как разработка программного обеспечения, маркетинговые кампании, организация мероприятий и т.д. Каждый тип проекта имеет свои собственные характеристики, такие как список задач, бюджет, сроки и т.д. Чтобы упростить процесс создания новых проектов, было принято решение использовать паттерн "Строитель". Создается абстрактный класс ProjectBuilder, определяющий общие методы для построения проекта: addTasks, setDeadline, setManager. Для каждого типа проекта создается конкретный класс-строитель, наследующий от ProjectBuilder. Каждый из этих классов реализует специфические для своего типа проекта методы.

3) **Мост (Bridge)**
Представим, что вы разрабатываете систему аналитики для различных типов клиентских приложений (веб-сайт, мобильное приложение, настольное приложение). Эта система должна предоставлять единый интерфейс для сбора и анализа данных, но при этом иметь возможность поддерживать разные источники данных (Google Analytics, Yandex.Metrika, Adobe Analytics и т.д.). Определите абстрактный интерфейс AnalyticsProvider, который будет определять общие методы для работы с источниками данных (например, getVisitorStats, getTrafficSources, getConversionRates). Объект получения аналитического отчёта должен формировать отчёт для конкретного типа клиентского приложения, получая данные из конкретного источника. Реализуйте паттерн Мост, чтобы можно было гибко добавлять поддержку новых источников данных и типов клиентских приложений. 

4) **Компоновщик (Composite)**
Мы пишем свою реализацию HTML. Есть интерфейс HTML-элемента (DOMNode), содержащий метод render() (возвращает html-код элемента и его содержимого в виде строки). В структуре HTML документа может быть 2 типа узлов: обычный текст и HTML-элемент (например, теги `html <p>, <div>`). Каждый HTML-элемент может содержать произвольное число дочерних узлов, а также список атрибутов (например, class, id, style). Реализовать возможность построения древовидной структуры HTML-документа с рендерингом всего этого дерева в HTML-код. После рендеринга на выходе должно получаться что-то вроде: `html“<div id=”my-block”><p class=”my-text”>Строка 1</p><p>Строка 2</p></div>”`.

5) **Декоратор (Decorator)**
Пусть мы пишем функциональность логирования (запись сообщений об ошибках, предупреждениях и прочем). Абстрактный класс Logger содержит метод логирования сообщения log(message, level), где message - сообщение, level - уровень сообщения. Имеется базовый логгер по-умолчанию, который логирует в стандартный поток вывода (то есть консоль), а также 3 вида конкретных логгеров: FileLogger, RemoteLogger, DataBaseLogger, отличающихся тем, куда они сохраняют сообщения. Для каждого логгера можно задать один из 3 уровней: Info, Debug, Error. Если для логгера задан уровень Info, он сохраняет любые передаваемые ему сообщения. Если Debug - сообщения уровня Debug и Error. Если Error - только сообщения уровня Error. Реализовать паттерн декоратор для возможности сочетать и гибко добавлять поддержку различных методов логирования.

6) **Цепочка обязанностей (Chain of Responsibility)**
Вы реализуете свой веб-фреймворк. Типовым архитектурным решением в веб-фреймворках является организация цепочки обработчиков поступившего HTTP-запроса (Middlewares). Реализуйте класс запроса и классы различных возможных обработчиков: LoggingMiddleware (логирование запроса), AuthenticationMiddleware (аутентификация пользователя, инициализирует у объекта запроса экземпляр текущего пользователя при успешной аутентификации), CacheMiddleware (проверяет, есть ли закешированный вариант ответа и отдаёт его при нахождении), AuthorizationMiddleware (проверяет наличие у текущего юзера прав на выполнение данного запроса, отказывает в дальнейшем выполнении запроса при неудачной проверке), RouteMiddleware (определяет, какому обработчику, т.е. методу контроллера или сервису, отдать запрос в конечном счёте).

7) **Команда (Command)**
Представьте, что вы разрабатываете редактор 2D-графики, где пользователи могут создавать, перемещать и удалять различные фигуры (например, прямоугольники, круги, линии). Пользователи должны иметь возможность выполнять следующие действия: создавать новую фигуру, перемещать фигуру, удалять фигуру. Все действия реализуют базовый интерфейс Command (с методами execute и undo). Требуется поддержка функциональности Undo / Redo (отката последнего действия / повторного применения).

8) **Наблюдатель (Observer)**
Мы реализуем систему мониторинга загруженности сервера (загруженности его процессора). Загруженность измеряется в процентах. Реализуйте класс CPUUsageMetric (с методом update для обновления значения загруженности), который позволяет уведомлять об изменении в нагрузке. Реализуйте 3 подписчика: CPUUsageLogger (который добавляет в файл лога новое значение загруженности с меткой времени, если оно отличается от предыдущего), CPUUsageNotifier (который посылает запрос с новым значением метрики некому удалённому сервису), CPUScaler (который увеличивает мощность сервера, если нагрузка превышает заранее заданный лимит, и уменьшает, если нагрузка падает ниже).

9) **Состояние (State)**
Марио из известной игры-платформера умеет прыгать и (иногда) стрелять огненными шарами. Допустим он может находиться в одном из трех состояний в порядке увеличения силы: обычном, улучшенном и огненном. В улучшенном и огненном состоянии он прыгает выше, чем в обычном, а в огненном получает возможность стрелять шарами. Реализовать для Марио методы jump (прыгнуть), shoot (стрелять), powerUp (перейти в следующее по силе состояние), powerDown (понизить состояние до предыдущего по силе).

***В моем случае задача №5***
